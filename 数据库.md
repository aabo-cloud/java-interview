## 数据库

### 数据库基础

#### 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？

- **元组**：元组 (`tuple`) 是关系数据库中的基本概念，关系是表，表中的每行 (即数据库中的每条记录) 就是元组，每列就是一个属性。

- **码**：码就是实体的属性，对应表中的列。

- **候选码**：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性或属性组为候选码。

  > 例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。

- **主码**：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。

- **外码**: 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。

- **主属性**：候选码中出现过的属性称为主属性。

  > 例如：关系 工人 (工号，身份证号，姓名，性别，部门)。工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。

- **非主属性：**不包含在任何一个候选码中的属性称为非主属性。

#### 主键和外键有什么区别?

- **主键 (主码)**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。
- **外键 (外码)**：外键用来和其他表建立联系，是另一张表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。

#### 什么是 `ER` 图？

实体-联系图 (`Entity Relationship Diagram`)，提供了表示实体类型、属性和联系的方法，用来描述实体之间的关系。

#### 数据库范式？

第一范式：数据库表中所有字段都是不可分割的原子值。

第二范式：满足第一范式，且所有非主属性都完全依赖于主码。

第三范式：满足第二范式，所有非主属性对任何候选码都不存在依赖传递。

#### 什么是存储过程？

存储过程可以看成是一些 `SQL` 语句的集合，其中可以增加逻辑控制语句。

存储过程方便多次调用，比直接 `SQL` 语句执行要快，因为存储过程是预编译过的。

但是存储过程难以调试和扩展，没有移植性，还会消耗数据库资源。

#### `drop`、`delete` 与 `truncate` 区别？

- `drop` (丢弃数据)：`drop table 表名`，删除整张表，包括表结构。
- `truncate` (清空数据)：`truncate table 表名`，清空表中数据，再插入数据的时候自增 `id` 又从 `1` 开始。不产生数据库日志。
- `delete` (删除数据)：`delete from 表名 where 列名=值`，删除某一行的数据，如果不加 `where`，也会删除整张表的数据。会产生数据库的 `binlog` 日志。

#### 数据库设计通常分为哪几步？

1. **需求分析**：分析用户的需求，包括数据、功能和性能需求。
2. **概念结构设计**：画 `E-R` 图。
3. **逻辑结构设计**：将 `E-R` 图转换成关系表。
4. **物理结构设计**：为所设计的数据库选择合适的存储结构和存取路径。
5. **数据库实施**：编程、测试和试运行。
6. **数据库的运行和维护**：系统的运行与数据库的日常维护。

### MySQL

`MySql` 是关系型数据库。就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系 (一对一、一对多、多对多)。

关系型数据库中，数据都被存放在了各种表中 (比如用户表)，表中的每一行就存放着一条数据 (比如一个用户的信息)。

#### 简述 `MySQL` 的架构？

* `Server` 层
  * **连接器：** 身份权限认证 (登录 `MySQL` 的时候)。
  * **查询缓存：** 执行查询语句的时候，会先查询缓存（`MySQL 8.0` 版本后移除）。
  * **分析器：** 没有命中缓存的话，`SQL` 语句就会经过分析器，分析并检查 `SQL` 语法。
  * **优化器：** 按照 `MySQL` 认为最优的方案去执行。
  * **执行器：** 执行语句，然后从存储引擎返回数据。

* 存储引擎：存储数据，提供读写接口。支持 `InnoDB`、`MyISAM`

#### 简述执行 `SQL` 语言的过程？

查询语句：

* 客户端首先通过**连接器**进行身份和权限认证。
* 如果执行的是查询语句，会先查询缓存，`MySQL 8.0` 后该步骤移除。
* 如果没有命中缓存，`SQL` 语句就会经过解析器，分析语句，包括语法检查等等。
* 接下来通过优化器，将 `SQL` 语句按照 `MySQL` 认为最优的方案去执行。
* 从存储引擎返回数据。

更新语句：

- 查询到需要修改的数据，如果有缓存，也会用到缓存。
- 对数据进行修改，调用引擎 `API` 接口，准备写入这一行数据。`InnoDB` 引擎会把数据保存在内存中，同时记录 `redo log`，此时 `redo log` 进入 `prepare` 状态，然后告诉执行器，随时可以提交。
- 执行器收到通知后记录 `binlog`，然后调用引擎接口，提交 `redo log`。
- 更新完成。

##### 为什么 `redo log` 需要先进入 `prepare` 状态？

`binlog` 是 `MySQL`自带的归档日志 (数据备份、主从同步)，`redo log` 是 `InnoDB` 的重做日志 (用来支持事务)。

- **先写 `redo log` 直接提交，然后写 `binlog`**。假设写完 `redo log` 并提交后，机器挂了，`binlog` 日志没有被写入，那么机器重启后，这台机器会通过 `redo log` 恢复数据，但是 `binlog` 并没有记录该数据，后续进行机器备份或主从同步时的时候，就会丢失这些数据。

- **先写 `binlog`，然后写 `redo log`**。假设写完了 `binlog`，机器挂了，由于没有 `redo log`，本机是无法恢复这一条记录的，但是 `binlog` 又有记录，同样会产生数据不一致的情况。

- 假设 `redo log` 处于预提交状态，`binlog` 也已经写完了，机器挂了。依赖 `MySQL` 的处理机制：

  当 `redo log` 只是预提交但不是 `commit` 状态，判断 `binlog` 是否完整，如果完整就提交 `redo log`，不完整就回滚事务。

#### 存储引擎？

`MySQL` 有 `MyISAM` 和 `InnoDB` 等存储引擎。

##### `MyISAM` 和 `InnoDB` 的区别？

* **锁的级别不同。**

  `MyISAM` 只有表级锁 (`table-level locking`)，而 `InnoDB` 支持行级锁 (`row-level locking`) 和表级锁，默认为行级锁。表级锁会一次性锁住整张表，非常影响对数据库并发操作的性能。

* **是否支持事务。**

  `MyISAM` 不支持事务。`InnoDB` 支持事务，具有提交 (`commit`) 和回滚 (`rollback`) 事务的能力。使用 **`undo log` (回滚日志)** 来保证事务的**原子性**。

* **是否支持外键。**

  `MyISAM` 不支持外键，而 `InnoDB` 支持。

* **数据库异常崩溃后的安全恢复能力。**

  `MyISAM` 不支持。

  使用 `InnoDB` 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log`，可以保证数据的**持久性**。

#### `MySQL` 日志

`MySQL` 日志中比较重要的是 `binlog` (归档日志)、`redo log` (重做日志) 和 `undo log` (回滚日志)。

##### `redo log` (重做日志)

`redo log` (重做日志) 是 `InnoDB` 存储引擎独有的，它让 `MySQL` 拥有了崩溃恢复能力。当 `MySQL` 实例挂了，重启时，`InnoDB` 存储引擎会使用 `redo log` 恢复数据，**保证数据的持久性**。

`redo log` 是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 `InnoDB` 存储引擎。

// TODO more specific

##### `undo log` (回滚日志)

事务的回滚是通过 **`undo log`** 实现的，所有事务进行的修改都会先记录到回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，直接利用 **回滚日志** 中的信息将数据回滚到修改之前。

回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚之前未完成的事务。**保证事务的原子性。**

##### `binlog` (归档日志)

`binlog` 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 x 字段加 1”。

不管用什么存储引擎，只要发生了表数据更新，都会产生 `binlog` 日志。

`MySQL` 的**数据备份、主备、主主、主从**都需要依靠 `binlog` 来同步数据，**保证数据一致性。**

// TODO more specific

#### 锁机制与 `InnoDB` 锁算法？

##### **表级锁和行级锁对比：**

- **表级锁：** `MySQL` 中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁。实现简单，资源消耗少，加锁快，不会出现死锁。触发锁冲突的概率最高，并发度最低，`MyISAM` 和 `InnoDB` 引擎都支持表级锁。
- **行级锁：** `MySQL` 中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。加锁开销大，加锁慢，会出现死锁。 触发锁冲突的概率小，并发度高。

**`InnoDB` 存储引擎的锁算法：**

- `Record lock`：记录锁，单个行记录上的锁
- `Gap lock`：间隙锁，锁定一个范围，不包括记录本身
- `Next-key lock`：`record+gap` 临键锁，锁定一个范围，包含记录本身

// TODO 这都是些什么东西

##### `MVCC`？

// TODO



#### 索引

索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有：B 树， B+树和 Hash。

##### 索引的优缺点

优点 ：

- 使用索引可以加快数据的检索速度。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

缺点 ：

- 创建索引和维护索引需要耗费时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 `SQL` 执行效率。
- 索引需要使用物理文件存储，会耗费一定空间。

##### 索引的底层数据结构？

`Hash` 表：不适合用作 `MySQL` 索引。会产生 `Hash` 冲突。

`B` 树：



`B+` 树：



##### 索引类型？

###### 主键索引 (`Primary Key`)：

数据表的主键列使用的就是主键索引。一张数据表有只能有一个主键，并且主键不能为 `null`，不能重复。

使用 `InnoDB` 时，当没有显示的指定表的主键时，`InnoDB` 会先检查表中是否有唯一索引且不允许存在`null` 值的字段，如果有，则选择该字段为默认的主键。否则 `InnoDB` 会自动创建一个自增主键。

// TODO 索引



#### 数据库事务

详见 [`Spring`事务](Spring.md)。东西都一样。

#### `MySQL` 优化

// TODO





### Redis

内存数据库，`Key-Value` 数据库。

`Redis` 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。

`Redis` 提供了多种数据类型来支持不同的业务场景。`Redis` 还支持事务 、持久化、`Lua` 脚本、多种集群方案。

#### 为什么要用 `Redis` / 缓存？

**高性能**：

把用户访问频率较高的数据放在 `Redis` 中，可以提高读取速度。

**高并发**：

一般像 `MySQL` 这类的数据库的 `QPS` 大概都在 `1w` 左右 (4 核 8g)，但是使用 `Redis` 缓存之后很容易达到 `10w+`，`redis` 集群会更高。

> QPS (Query Per Second)：服务器每秒可以执行的查询次数；

直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以如果把数据库中的部分数据转移到缓存中去，用户的一部分请求会直接到缓存而不用经过数据库。提高了系统整体的并发。

#### `Redis` 除了做缓存，还能做什么？

- **分布式锁**： 通过 `Redis` 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 `Redisson` 来实现分布式锁。相关阅读：[《分布式锁中的王者方案 - Redisson》open in new window](https://mp.weixin.qq.com/s/CbnPRfvq4m1sqo2uKI6qQw)。
- **限流**：一般是通过 `Redis + Lua` 脚本的方式来实现限流。相关阅读：[《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》open in new window](https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA)。
- **消息队列**：`Redis` 自带的 `list` 数据结构可以作为一个简单的队列使用。`Redis 5.0` 中增加的 `Stream` 类型的数据结构更加适合用来做消息队列。它比较类似于 `Kafka`，有主题和消费组的概念，支持消息持久化以及 `ACK` 机制。
- **复杂业务场景**：通过 `Redis` 以及 `Redis` 扩展 (比如 `Redisson`) 提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 `bitmap` 统计活跃用户、通过 `sorted set` 维护排行榜。
- ......



#### `Redis` 常见数据结构？

**string**

string 数据结构是简单的 key-value 类型。

 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。

**list**

Redis 的 list 的实现为一个 **双向链表**，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

发布与订阅或者消息队列、慢查询。

**hash**

hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。

hash 是一个 string 类型的 field 和 value 的映射表，**特别适合用于存储对象**。 比如可以使用 hash 来存储用户信息，商品信息等等。

**set**

set 类似于 Java 中的 `HashSet`。基于 set 很容易实现交集、并集、差集的操作。

set 可以很方便实现共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。

**sorted set**

和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。

需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息等信息。

**bitmap**

bitmap 存储的是连续的二进制数字 (0 和 1)，通过 bitmap，只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身。bitmap 会极大的节省储存空间。

适合需要保存状态信息 (比如是否签到、是否登录...) 并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计 (比如是否点赞过某个视频)。

#### Redis 线程模型？

##### Redis 单线程模型？

**Redis 基于 Reactor 模式来设计开发了一套高效的事件处理模型**，这套事件处理模型对应的是 `Redis` 中的文件事件处理器 (`file event handler`)。由于文件事件处理器是单线程方式运行的，所以一般都说 `Redis` 是单线程模型。

##### 单线程模型怎么监听大量的客户端连接？

`Redis` 的文件事件处理器使用 I/O 多路复用 (multiplexing) 程序来同时监听多个 `socket`，并根据 `socket` 目前执行的任务来关联不同的事件处理器。

文件事件处理器主要包含 4 个部分：

- 监听多个 socket（客户端连接）
- IO 多路复用程序（支持多个客户端连接的关键）
- 文件事件分派器（将 socket 关联到相应的事件处理器）
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

##### Redis6.0 之前为什么不使用多线程、之后为什么引入多线程？

不使用：

1. 单线程编程容易并且更容易维护；
2. `Redis` 的性能瓶颈不在 `CPU`，主要在内存和网络；
3. 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。

使用：

引入多线程主要是为了提高网络 IO 读写性能。

#### Redis 内存管理

##### 为什么要给数据设置过期时间？

内存有限，一直保存可能会 OOM。

有业务场景需要某个数据只在某一时间段内存在，比如短信验证码、用户登录的 token。

##### Redis 是如何判断数据是否过期？

`Redis` 中有 `redisDb` 这个数据结构，其中存放着 `expires` 过期字典 (可以看作是 `hash` 表) 来保存数据过期的时间。

过期字典的键指向 `Redis` 数据库中的某个 `key`，过期字典的值是一个 `long long` 类型的整数，这个整数保存了 `key` 所指向的数据库键的过期时间 (毫秒精度的 `UNIX` 时间戳)。

##### 过期的数据的删除策略？

1. **惰性删除** ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。
2. **定期删除** ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。

定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 **定期删除+惰性/懒汉式删除** 。

可能存在定期删除和惰性删除漏掉了很多过期 `key` 的情况。这样就导致大量过期 `key` 堆积在内存里，然后就 `OOM` 了。所以需要内存淘汰机制。

##### Redis 内存淘汰机制？

1. **volatile-lru（least recently used）**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. ***allkeys-lru（least recently used）**：当内存不足时，移除最近最少使用的 key（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。

4.0 版本后增加以下两种：

1. **volatile-lfu（least frequently used）**：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰
2. **allkeys-lfu（least frequently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

#### Redis 持久化机制

##### 怎么保证 Redis 挂掉之后再重启数据可以进行恢复？

持久化 Redis 数据。

**RDB 持久化：**

Redis 通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。

可以将快照复制到其他服务器从而创建具有相同数据的服务器副本，还可以将快照留在原地以便重启服务器的时候使用。

**AOF 持久化：**

开启 `AOF` 持久化后每执行一条会更改 `Redis` 中的数据的命令，`Redis` 就会将该命令写入到内存缓存 `server.aof_buf` 中，然后再根据 `appendfsync` 配置来决定什么时候将其同步到硬盘中的 `AOF` 文件 `appendonly.aof`。

#### Redis 事务

1. 开始事务（`MULTI`）。
2. 命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。
3. 执行事务(`EXEC`)。

不支持事务的原子性，执行过的命令不会被回滚。

#### Redis 性能优化

避免写入 `bigkey`。内存空间消耗大。

使用 `--bigkeys` 可以查找。

> string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个。

避免大量 key 集中过期。redis 会因为清理过期 key，导致不能及时处理客户端请求。

给 key 设置随机过期时间。

开启 lazy-free，将清理过期 key 的任务交给子线程操作。

#### Redis 生产问题

##### 缓存穿透

大量请求的 key 不存在于缓存中，导致请求直接到了数据库上。可能导致数据库宕机。

> 举个例子：某个黑客故意制造缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。

解决办法：

**参数校验。**

不合法的参数直接抛出异常信息给客户端。

**缓存无效 `key`。**

如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间。这种方式可以解决请求的 key 变化不频繁的情况。如果遭到恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。

**布隆过滤器。**

布隆过滤器可以快速判断一个元素是否存在。**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话再继续去缓存和数据库中寻找数据。

##### 缓存雪崩

缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。

解决办法：

**针对 Redis 服务不可用的情况：**

1. 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
2. 限流，避免同时处理大量的请求。

**针对热点缓存失效的情况：**

1. 设置不同的失效时间比如随机设置缓存的失效时间。
2. 缓存永不失效。

##### 如何保证缓存和数据库数据的一致性？

Cache Aside Pattern（旁路缓存模式）

// TODO
