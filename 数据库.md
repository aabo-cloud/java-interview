## 数据库

### 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？



### 主键和外键有什么区别?



### 什么是 `ER` 图？



### 数据库范式？



### 什么是存储过程？



### `drop`、`delete` 与 `truncate` 区别？



### 数据库设计通常分为哪几步？



### MySQL

`MySql` 是关系型数据库。就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系 (一对一、一对多、多对多)。

关系型数据库中，数据都被存放在了各种表中 (比如用户表)，表中的每一行就存放着一条数据 (比如一个用户的信息)。

#### 存储引擎？

`MySQL` 有 `MyISAM` 和 `InnoDB` 等存储引擎。

##### `MyISAM` 和 `InnoDB` 的区别？

* **锁的级别不同。**

  `MyISAM` 只有表级锁 (`table-level locking`)，而 `InnoDB` 支持行级锁 (`row-level locking`) 和表级锁，默认为行级锁。表级锁会一次性锁住整张表，非常影响对数据库并发操作的性能。

* **是否支持事务。**

  `MyISAM` 不支持事务。`InnoDB` 支持事务，具有提交 (`commit`) 和回滚 (`rollback`) 事务的能力。使用 **`undo log` (回滚日志)** 来保证事务的**原子性**。

* **是否支持外键。**

  `MyISAM` 不支持外键，而 `InnoDB` 支持。

* **数据库异常崩溃后的安全恢复能力。**

  `MyISAM` 不支持。

  使用 `InnoDB` 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log`，可以保证事务的**持久性**。

#### `MVCC`？

// TODO



#### 锁机制与 `InnoDB` 锁算法？

##### **表级锁和行级锁对比：**

- **表级锁：** `MySQL` 中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁。实现简单，资源消耗少，加锁快，不会出现死锁。触发锁冲突的概率最高，并发度最低，`MyISAM` 和 `InnoDB` 引擎都支持表级锁。
- **行级锁：** `MySQL` 中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。加锁开销大，加锁慢，会出现死锁。 触发锁冲突的概率小，并发度高。

**`InnoDB` 存储引擎的锁算法：**

- `Record lock`：记录锁，单个行记录上的锁
- `Gap lock`：间隙锁，锁定一个范围，不包括记录本身
- `Next-key lock`：`record+gap` 临键锁，锁定一个范围，包含记录本身

// TODO 这都是些什么东西



#### 查询缓存

// TODO



#### 索引

索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有：B 树， B+树和 Hash。

##### 索引的优缺点

优点 ：

- 使用索引可以加快数据的检索速度。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

缺点 ：

- 创建索引和维护索引需要耗费时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 `SQL` 执行效率。
- 索引需要使用物理文件存储，会耗费一定空间。

##### 索引的底层数据结构？

`Hash` 表：不适合用作 `MySQL` 索引。会产生 `Hash` 冲突。

`B` 树：



`B+` 树：



##### 索引类型？

###### 主键索引 (`Primary Key`)：

数据表的主键列使用的就是主键索引。一张数据表有只能有一个主键，并且主键不能为 `null`，不能重复。

使用 `InnoDB` 时，当没有显示的指定表的主键时，`InnoDB` 会先检查表中是否有唯一索引且不允许存在`null` 值的字段，如果有，则选择该字段为默认的主键。否则 `InnoDB` 会自动创建一个自增主键。







#### 数据库事务

详见 [`Spring`事务](Spring.md)。东西都一样。

#### `MySQL` 优化















