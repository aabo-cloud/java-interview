## 数据库

### 数据库基础

#### 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？

- **元组**：元组 (`tuple`) 是关系数据库中的基本概念，关系是表，表中的每行 (即数据库中的每条记录) 就是元组，每列就是一个属性。

- **码**：码就是实体的属性，对应表中的列。

- **候选码**：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性或属性组为候选码。

  > 例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。

- **主码**：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。

- **外码**: 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。

- **主属性**：候选码中出现过的属性称为主属性。

  > 例如：关系 工人 (工号，身份证号，姓名，性别，部门)。工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。

- **非主属性：**不包含在任何一个候选码中的属性称为非主属性。

#### 主键和外键有什么区别?

- **主键 (主码)**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。
- **外键 (外码)**：外键用来和其他表建立联系，是另一张表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。

#### 什么是 `ER` 图？

实体-联系图 (`Entity Relationship Diagram`)，提供了表示实体类型、属性和联系的方法，用来描述实体之间的关系。

#### 数据库范式？

第一范式：数据库表中所有字段都是不可分割的原子值。

第二范式：满足第一范式，且所有非主属性都完全依赖于主码。

第三范式：满足第二范式，所有非主属性对任何候选码都不存在依赖传递。

#### 什么是存储过程？

存储过程可以看成是一些 `SQL` 语句的集合，其中可以增加逻辑控制语句。

存储过程方便多次调用，比直接 `SQL` 语句执行要快，因为存储过程是预编译过的。

但是存储过程难以调试和扩展，没有移植性，还会消耗数据库资源。

#### `drop`、`delete` 与 `truncate` 区别？

- `drop` (丢弃数据)：`drop table 表名`，删除整张表，包括表结构。
- `truncate` (清空数据)：`truncate table 表名`，清空表中数据，再插入数据的时候自增 `id` 又从 `1` 开始。不产生数据库日志。
- `delete` (删除数据)：`delete from 表名 where 列名=值`，删除某一行的数据，如果不加 `where`，也会删除整张表的数据。会产生数据库的 `binlog` 日志。

#### 数据库设计通常分为哪几步？

1. **需求分析**：分析用户的需求，包括数据、功能和性能需求。
2. **概念结构设计**：画 `E-R` 图。
3. **逻辑结构设计**：将 `E-R` 图转换成关系表。
4. **物理结构设计**：为所设计的数据库选择合适的存储结构和存取路径。
5. **数据库实施**：编程、测试和试运行。
6. **数据库的运行和维护**：系统的运行与数据库的日常维护。

### MySQL

`MySql` 是关系型数据库。就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系 (一对一、一对多、多对多)。

关系型数据库中，数据都被存放在了各种表中 (比如用户表)，表中的每一行就存放着一条数据 (比如一个用户的信息)。

#### 简述 `MySQL` 的架构？

* `Server` 层
  * **连接器：** 身份权限认证 (登录 `MySQL` 的时候)。
  * **查询缓存：** 执行查询语句的时候，会先查询缓存（`MySQL 8.0` 版本后移除）。
  * **分析器：** 没有命中缓存的话，`SQL` 语句就会经过分析器，分析并检查 `SQL` 语法。
  * **优化器：** 按照 `MySQL` 认为最优的方案去执行。
  * **执行器：** 执行语句，然后从存储引擎返回数据。

* 存储引擎：存储数据，提供读写接口。支持 `InnoDB`、`MyISAM`

#### 简述执行 `SQL` 语言的过程？

查询语句：

* 客户端首先通过**连接器**进行身份和权限认证。
* 如果执行的是查询语句，会先查询缓存，`MySQL 8.0` 后该步骤移除。
* 如果没有命中缓存，`SQL` 语句就会经过解析器，分析语句，包括语法检查等等。
* 接下来通过优化器，将 `SQL` 语句按照 `MySQL` 认为最优的方案去执行。
* 从存储引擎返回数据。

更新语句：

- 查询到需要修改的数据，如果有缓存，也会用到缓存。
- 对数据进行修改，调用引擎 `API` 接口，准备写入这一行数据。`InnoDB` 引擎会把数据保存在内存中，同时记录 `redo log`，此时 `redo log` 进入 `prepare` 状态，然后告诉执行器，随时可以提交。
- 执行器收到通知后记录 `binlog`，然后调用引擎接口，提交 `redo log`。
- 更新完成。

##### 为什么 `redo log` 需要先进入 `prepare` 状态？

`binlog` 是 `MySQL`自带的归档日志 (数据备份、主从同步)，`redo log` 是 `InnoDB` 的重做日志 (用来支持事务)。

- **先写 `redo log` 直接提交，然后写 `binlog`**。假设写完 `redo log` 并提交后，机器挂了，`binlog` 日志没有被写入，那么机器重启后，这台机器会通过 `redo log` 恢复数据，但是 `binlog` 并没有记录该数据，后续进行机器备份或主从同步时的时候，就会丢失这些数据。

- **先写 `binlog`，然后写 `redo log`**。假设写完了 `binlog`，机器挂了，由于没有 `redo log`，本机是无法恢复这一条记录的，但是 `binlog` 又有记录，同样会产生数据不一致的情况。

- 假设 `redo log` 处于预提交状态，`binlog` 也已经写完了，机器挂了。依赖 `MySQL` 的处理机制：

  当 `redo log` 只是预提交但不是 `commit` 状态，判断 `binlog` 是否完整，如果完整就提交 `redo log`，不完整就回滚事务。

#### 存储引擎？

`MySQL` 有 `MyISAM` 和 `InnoDB` 等存储引擎。

##### `MyISAM` 和 `InnoDB` 的区别？

* **锁的级别不同。**

  `MyISAM` 只有表级锁 (`table-level locking`)，而 `InnoDB` 支持行级锁 (`row-level locking`) 和表级锁，默认为行级锁。表级锁会一次性锁住整张表，非常影响对数据库并发操作的性能。

* **是否支持事务。**

  `MyISAM` 不支持事务。`InnoDB` 支持事务，具有提交 (`commit`) 和回滚 (`rollback`) 事务的能力。使用 **`undo log` (回滚日志)** 来保证事务的**原子性**。

* **是否支持外键。**

  `MyISAM` 不支持外键，而 `InnoDB` 支持。

* **数据库异常崩溃后的安全恢复能力。**

  `MyISAM` 不支持。

  使用 `InnoDB` 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log`，可以保证数据的**持久性**。

#### `MySQL` 日志

`MySQL` 日志中比较重要的是 `binlog` (归档日志)、`redo log` (重做日志) 和 `undo log` (回滚日志)。

##### `redo log` (重做日志)

`redo log` (重做日志) 是 `InnoDB` 存储引擎独有的，它让 `MySQL` 拥有了崩溃恢复能力。当 `MySQL` 实例挂了，重启时，`InnoDB` 存储引擎会使用 `redo log` 恢复数据，**保证数据的持久性**。

`redo log` 是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 `InnoDB` 存储引擎。

// TODO more specific

##### `undo log` (回滚日志)

事务的回滚是通过 **`undo log`** 实现的，所有事务进行的修改都会先记录到回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，直接利用 **回滚日志** 中的信息将数据回滚到修改之前。

回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚之前未完成的事务。**保证事务的原子性。**

##### `binlog` (归档日志)

`binlog` 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 x 字段加 1”。

不管用什么存储引擎，只要发生了表数据更新，都会产生 `binlog` 日志。

`MySQL` 的**数据备份、主备、主主、主从**都需要依靠 `binlog` 来同步数据，**保证数据一致性。**

// TODO more specific

#### 锁机制与 `InnoDB` 锁算法？

##### **表级锁和行级锁对比：**

- **表级锁：** `MySQL` 中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁。实现简单，资源消耗少，加锁快，不会出现死锁。触发锁冲突的概率最高，并发度最低，`MyISAM` 和 `InnoDB` 引擎都支持表级锁。
- **行级锁：** `MySQL` 中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。加锁开销大，加锁慢，会出现死锁。 触发锁冲突的概率小，并发度高。

**`InnoDB` 存储引擎的锁算法：**

- `Record lock`：记录锁，单个行记录上的锁
- `Gap lock`：间隙锁，锁定一个范围，不包括记录本身
- `Next-key lock`：`record+gap` 临键锁，锁定一个范围，包含记录本身

// TODO 这都是些什么东西

##### `MVCC`？

// TODO



#### 索引

索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有：B 树， B+树和 Hash。

##### 索引的优缺点

优点 ：

- 使用索引可以加快数据的检索速度。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

缺点 ：

- 创建索引和维护索引需要耗费时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 `SQL` 执行效率。
- 索引需要使用物理文件存储，会耗费一定空间。

##### 索引的底层数据结构？

`Hash` 表：不适合用作 `MySQL` 索引。会产生 `Hash` 冲突。

`B` 树：



`B+` 树：



##### 索引类型？

###### 主键索引 (`Primary Key`)：

数据表的主键列使用的就是主键索引。一张数据表有只能有一个主键，并且主键不能为 `null`，不能重复。

使用 `InnoDB` 时，当没有显示的指定表的主键时，`InnoDB` 会先检查表中是否有唯一索引且不允许存在`null` 值的字段，如果有，则选择该字段为默认的主键。否则 `InnoDB` 会自动创建一个自增主键。

// TODO 索引



#### 数据库事务

详见 [`Spring`事务](Spring.md)。东西都一样。

#### `MySQL` 优化

// TODO





### Redis

内存数据库，`Key-Value` 数据库。

`Redis` 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。

`Redis` 提供了多种数据类型来支持不同的业务场景。`Redis` 还支持事务 、持久化、`Lua` 脚本、多种集群方案。

#### 为什么要用 `Redis` / 缓存？

**高性能**：

把用户访问频率较高的数据放在 `Redis` 中，可以提高读取速度。

**高并发**：

一般像 `MySQL` 这类的数据库的 `QPS` 大概都在 `1w` 左右 (4 核 8g)，但是使用 `Redis` 缓存之后很容易达到 `10w+`，`redis` 集群会更高。

> QPS (Query Per Second)：服务器每秒可以执行的查询次数；

直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以如果把数据库中的部分数据转移到缓存中去，用户的一部分请求会直接到缓存而不用经过数据库。提高了系统整体的并发。

#### `Redis` 除了做缓存，还能做什么？

- **分布式锁**： 通过 `Redis` 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 `Redisson` 来实现分布式锁。相关阅读：[《分布式锁中的王者方案 - Redisson》open in new window](https://mp.weixin.qq.com/s/CbnPRfvq4m1sqo2uKI6qQw)。
- **限流**：一般是通过 `Redis + Lua` 脚本的方式来实现限流。相关阅读：[《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》open in new window](https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA)。
- **消息队列**：`Redis` 自带的 `list` 数据结构可以作为一个简单的队列使用。`Redis 5.0` 中增加的 `Stream` 类型的数据结构更加适合用来做消息队列。它比较类似于 `Kafka`，有主题和消费组的概念，支持消息持久化以及 `ACK` 机制。
- **复杂业务场景**：通过 `Redis` 以及 `Redis` 扩展 (比如 `Redisson`) 提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 `bitmap` 统计活跃用户、通过 `sorted set` 维护排行榜。
- ......



#### `Redis` 常见数据结构？

**string**

string 数据结构是简单的 key-value 类型。

 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。

**list**

Redis 的 list 的实现为一个 **双向链表**，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

发布与订阅或者消息队列、慢查询。

**hash**

hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。

hash 是一个 string 类型的 field 和 value 的映射表，**特别适合用于存储对象**。 比如可以使用 hash 来存储用户信息，商品信息等等。

**set**

set 类似于 Java 中的 `HashSet`。基于 set 很容易实现交集、并集、差集的操作。

set 可以很方便实现共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。

**sorted set**

和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。

需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息等信息。

**bitmap**

bitmap 存储的是连续的二进制数字 (0 和 1)，通过 bitmap，只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身。bitmap 会极大的节省储存空间。

适合需要保存状态信息 (比如是否签到、是否登录...) 并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计 (比如是否点赞过某个视频)。

#### `Redis` 线程模型？









