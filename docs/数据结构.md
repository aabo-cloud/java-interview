# 数据结构


> 详见 data-structure module

## 表

### 跳表 (SkipList)

redis 中有序集合，就是用跳表实现的，因为 redis 常用的一个操作是，按照区间查找数据，这种操作在红黑树等有序结构中，实现比较复杂，而在跳表中，只需找到区间最小值，然后依次向后遍历即可，非常高效；

- 跳表结合了链表和二分查找的思想
- 由原始链表和一些通过“跳跃”生成的链表组成
- 第0层是原始链表，越上层“跳跃”的越高，元素越少
- 上层链表是下层链表的子序列
- 查找时从顶层向下，不断缩小搜索范围

**空间复杂度**

跳表还是通过建立的索引的方式来加快查找速度，必然会占用内存。

假设原始链表大小为n，第一层有大约 n/2，第二层有 n/4...以此类推直到剩下最后两个节点。

相加为 n-2 因此空间复杂度为 O(n)。

**时间复杂度**

二分的思想 O(lgn)

## 树

### 二叉排序树

...

### AVL 树

由于二叉排序树生成的树的形状可能为单枝树，所以查找的最坏时间复杂度为 O(n)。为了尽量减少树的高度，把时间复杂度稳定在 O(lgn) 提出了 AVL树。

满足以下性质：

- 每个节点最多只有两个子节点（二叉）。
- 每个节点的值比它的左子树所有的节点大，比它的右子树所有节点小（有序）。
- 每个节点左子树的高度与右子树高度之差的绝对值 (平衡因子) 不超过1。

### 红黑树

红黑树是一种自平衡二叉排序树，它属于平衡树，但是却没有AVL树那么“平衡”。

由于 AVL树 对树的平衡性要求非常高，所以在插入和删除结点时非常复杂。各种旋转...

而红黑树对平衡的要求性没有 AVL树 那么高。从根到叶子的最长路径不大于最短路径的两倍就可以了。也就是查找的最坏时间复杂度为 O(2lgn) ，所以红黑树大致上是平衡的，和 AVL树 相差不多。但是红黑树可以通过变色的特性，避免自平衡时的一些旋转操作，提升效率。



满足以下性质：

* 性质1：每个节点是 红色 或者 黑色。

* 性质2：根节点是黑色。

* 性质3：每个叶子节点（NIL）是黑色。

* 性质4：每个红色结点的子结点一定是黑色，父节点一定是黑色。

* **性质5：任一结点到每个叶子结点的路径都包含数量相同的黑色结点。**












## 图论

### 并查集

```java
public class UnionFind {

    // 记录结点的父子关系
    private Map<Integer, Integer> father;
    // 记录每个集合的数据，用不到就不需要
    private Map<Integer, List<Integer>> set;
    // 记录集合个数
    private int numOfSet = 0;

    // 初始化
    public UnionFind() {
        father = new HashMap<>();
        set = new HashMap<>();
        numOfSet = 0;
    }

    // 将节点加入到集合中
    public void add(int x) {
        if (father.containsKey(x)) {
            return;
        }
        // 根结点的父结点为空
        father.put(x, null);
        set.put(x, ListUtils.newArrayList(x));
        numOfSet++;
    }

    // 合并两个节点
    public void merge(int x, int y) {
        // 找到两个节点的父节点
        int rootX = find(x);
        int rootY = find(y);
		// 如果节点不属于同一集合
        if (rootX != rootY) {
            // 将rootY作为rootX的父亲
            father.put(rootX, rootY);
            numOfSet--;
            // 合并集合
            set.get(rootY).addAll(set.get(rootX));
        }
    }

    // 寻找根节点
    public int find(int x) {
        int root = x;
        while (father.get(root) != null) {
            root = father.get(root);
        }
        // 将路径上所有节点的父节点都换成root
        while (x != root) {
            int originalFather = father.get(x);
            father.put(x, root);
            x = originalFather;
        }
        return root;
    }

    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }

    public List<Integer> getSet(int x) {
        return set.get(find(x));
    }

    public int getNumOfSet() {
        return numOfSet;
    }

}
```



## Hash 表

### 解决 Hash 冲突的集中方法

装填因子 (加载因子)：a=n/m 其中n 为关键字个数，m为表长。

#### 拉链法 (开散列)

对于相同的哈希值，使用链表进行连接。

优点

* 处理冲突简单，无堆积现象。即非同义词决不会发生冲突，因此平均查找长度较短；
* 适合总数经常变化的情况。（因为拉链法中各链表上的结点空间是动态申请的）
* 占空间小。装填因子可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计
* 删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。

缺点

* 查询时效率较低。（存储是动态的，查询时跳转需要更多的时间）
* 在key-value可以预知，以及没有后续增改操作时候，开放定址法性能优于链地址法。
* 不容易序列化

#### 开放定址法

* 线性探测再散列
* (平方)探测再散列
* 伪随机探测再散列

**优点**

* 容易序列化
* 若可预知数据总数，可以创建完美哈希数列

**缺点**

* 占空间很大。（开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间）
* 删除节点很麻烦。不能简单地将被删结点的空间置为空，否则将截断在它之后填入散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

开放地址法： 会产生堆积问题，不适合大规模的数据存储，插入时，可能会出现多次冲突的情况，删除数据时，其他数据也有影响，实现相对较为复杂。且节点规模大时，再平方探测会浪费空间。

拉链法： 处理冲突简单，且无堆积现象。平均查找长度短，时间复杂度低。链表中的节点是动态申请的，适合构造表不能确定的情况。相对而言，指针域可以忽略不计，所以更节省空间。尾插法简单，只需要修改指针，不需要对其他冲突做处理。

