### Redis

内存数据库，`Key-Value` 数据库。

`Redis` 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。

`Redis` 提供了多种数据类型来支持不同的业务场景。`Redis` 还支持事务 、持久化、`Lua` 脚本、多种集群方案。

#### 为什么要用 `Redis` / 缓存？

**高性能**：

把用户访问频率较高的数据放在 `Redis` 中，可以提高读取速度。

**高并发**：

一般像 `MySQL` 这类的数据库的 `QPS` 大概都在 `1w` 左右 (4 核 8g)，但是使用 `Redis` 缓存之后很容易达到 `10w+`，`redis` 集群会更高。

> QPS (Query Per Second)：服务器每秒可以执行的查询次数；

直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以如果把数据库中的部分数据转移到缓存中去，用户的一部分请求会直接到缓存而不用经过数据库。提高了系统整体的并发。

#### `Redis` 除了做缓存，还能做什么？

- **分布式锁**： 通过 `Redis` 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 `Redisson` 来实现分布式锁。相关阅读：[《分布式锁中的王者方案 - Redisson》open in new window](https://mp.weixin.qq.com/s/CbnPRfvq4m1sqo2uKI6qQw)。
- **限流**：一般是通过 `Redis + Lua` 脚本的方式来实现限流。相关阅读：[《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》open in new window](https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA)。
- **消息队列**：`Redis` 自带的 `list` 数据结构可以作为一个简单的队列使用。`Redis 5.0` 中增加的 `Stream` 类型的数据结构更加适合用来做消息队列。它比较类似于 `Kafka`，有主题和消费组的概念，支持消息持久化以及 `ACK` 机制。
- **复杂业务场景**：通过 `Redis` 以及 `Redis` 扩展 (比如 `Redisson`) 提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 `bitmap` 统计活跃用户、通过 `sorted set` 维护排行榜。

#### `Redis` 常见数据结构？

**string**

`string` 数据结构是简单的 `key-value` 类型。

 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。

**list**

`Redis` 的 `list` 是由 **双向链表** 实现的，可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

发布与订阅或者消息队列、慢查询。

**hash**

`hash` 类似于 `JDK1.8` 前的 `HashMap`，内部实现使用 (数组 + 链表)。

`hash` 是一个 `string` 类型的 `field` 和 `value` 的映射表，**适合用于存储对象**。 

可以使用 `hash` 来存储用户信息，商品信息等等。

**set**

`set` 类似于 `Java` 中的 `HashSet`。基于 `set` 很容易实现交集、并集、差集的操作。

可以方便实现共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。

**sorted set**

和 `set` 相比，`sorted set` 增加了一个权重参数 `score`，使得集合中的元素能够按 `score` 进行有序排列，还可以通过 `score` 的范围来获取元素的列表。

> 像 `Java` 中 `HashMap` 和 `TreeSet` 的结合体。

用于需要对数据根据某个权重进行排序的场景。

例如直播系统中的实时排行信息，各种礼物排行榜，弹幕消息等。

**bitmap**

`bitmap` 存储的是连续的二进制数字 (`0` 和 `1`)，通过 `bitmap`，只需要一个 `bit` 位来表示某个元素对应的值或者状态，极大的节省储存空间。

适合需要保存状态信息 (比如是否签到、是否登录...) 并需要进一步对这些信息进行分析的场景。

例如用户签到情况、活跃用户情况、用户行为统计 (是否点赞过某个视频...)。

#### Redis 线程模型？

##### Redis 单线程模型？

`Redis` 基于 `Reactor` 模式来设计开发了一套高效的事件处理模型，这套事件处理模型对应的是 `Redis` 中的文件事件处理器 (`file event handler`)。由于文件事件处理器是单线程方式运行的，所以一般都说 `Redis` 是单线程模型。

##### 单线程模型怎么监听大量的客户端连接？

`Redis` 的文件事件处理器基于 `I/O` 多路复用模型，通过使用 `Selector`，来同时监听多个 `socket`，并根据 `socket` 目前执行的任务来关联不同的事件处理器。

文件事件处理器主要包含 4 个部分：

- 监听多个 socket（客户端连接）
- IO 多路复用程序（支持多个客户端连接的关键）
- 文件事件分派器（将 socket 关联到相应的事件处理器）
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

##### Redis6.0 之前为什么不使用多线程、之后为什么引入多线程？

不使用：

1. 单线程编程容易并且更容易维护；
2. `Redis` 的性能瓶颈不在 `CPU`，主要在内存和网络；
3. 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。

使用：

引入多线程主要是为了提高网络 `IO` 读写性能。

#### Redis 内存管理

##### 为什么要给数据设置过期时间？

内存有限，一直保存可能会 `OOM`。

有业务场景需要某个数据只在某一时间段内存在，比如短信验证码、用户登录的 `token`。

##### Redis 是如何判断数据是否过期？

`Redis` 中有 `redisDb` 这个数据结构，其中存放着 `expires` 过期字典 (可以看作是 `hash` 表) 来保存数据过期的时间。

过期字典的键指向 `Redis` 数据库中的某个 `key`，过期字典的值是一个 `long long` 类型的整数，这个整数保存了 `key` 所指向的数据库键的过期时间 (毫秒精度的 `UNIX` 时间戳)。

##### 过期的数据的删除策略？

1. **惰性删除** ：只在取出 `key` 的时候才对数据进行过期检查。这样对 `CPU` 最友好，但是可能会造成太多过期 `key` 没有被删除。
2. **定期删除** ：每隔一段时间抽取一批 `key` 执行删除过期 `key` 操作。并且，`Redis` 底层会通过限制删除操作执行的时长和频率来减少删除操作对 `CPU` 的影响。

**定期删除**对内存更加友好，**惰性删除**对 `CPU` 更加友好。两者各有千秋，所以 `Redis` 采用的是 **定期删除+惰性删除** 。

可能存在定期删除和惰性删除漏掉了很多过期 `key` 的情况。这样就导致大量过期 `key` 堆积在内存里，然后就 `OOM` 了。所以需要内存淘汰机制。

##### Redis 内存淘汰机制？

1. **volatile-lru (least recently used)**：从已设置过期时间的数据 (server.db[i].expires) 中挑选**最近最少使用**的数据淘汰。
2. **volatile-ttl**：从已设置过期时间的数据中挑选**将要过期**的数据淘汰。
3. **volatile-random**：从已设置过期时间的数据中挑选**任意**数据淘汰。
4. ***allkeys-lru (least recently used)**：当内存不足时，从所有数据 (server.db[i].dict) 中挑选**最近最少使用**的数据淘汰。用的最多。
5. **allkeys-random**：从所有数据中挑选**任意**数据淘汰。
6. **no-eviction**：**禁止淘汰**数据，当内存不足以容纳新写入数据时会报错。

`4.0` 版本后增加以下两种：

1. **volatile-lfu (least frequently used)**：从已设置过期时间的数据中挑选**最不经常使用**的数据淘汰。
2. **allkeys-lfu (least frequently used)**：当内存不足时，挑选**最不经常使用**的数据淘汰。

#### Redis 持久化机制

##### 怎么保证 Redis 挂掉之后再重启数据可以进行恢复？

持久化 `Redis` 数据。

**RDB 持久化：**

`Redis` 通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。

可以将快照复制到其他服务器从而创建具有相同数据的服务器副本，还可以将快照留在原地以便重启服务器的时候使用。

**AOF 持久化：**

开启 `AOF` 持久化后每执行一条会更改 `Redis` 中的数据的命令，`Redis` 就会将该命令写入到内存缓存 `server.aof_buf` 中，然后再根据 `appendfsync` 配置来决定什么时候将其同步到硬盘中的 `AOF` 文件 `appendonly.aof`。

#### Redis 事务

1. 开始事务 (`MULTI`)。
2. 命令入队 (批量操作 `Redis` 的命令，先进先出的顺序执行)。
3. 执行事务 (`EXEC`)。

不支持事务的原子性，执行过的命令不会被回滚。

#### Redis 性能优化

* 避免写入 `bigkey`。内存空间消耗大。

  使用 `--bigkeys` 可以查找。

  > string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个。

* 避免大量 `key` 集中过期。`redis` 会因为清理过期 `key`，导致不能及时处理客户端请求。

  给 `key` 设置随机过期时间。开启 `lazy-free`，将清理过期 `key` 的任务交给子线程操作。

#### Redis 生产问题

##### 缓存穿透

大量请求的 `key` 不存在于缓存中，导致请求直接到了数据库上。可能导致数据库宕机。

> 举个例子：某个黑客故意制造缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。

解决办法：

* **参数校验。**

  不合法的参数直接抛出异常信息给客户端。

* **缓存无效 `key`。**

  如果缓存和数据库都查不到某个 `key`，就把这个 `key` 写到 `Redis` 中并设置过期时间。这种方式可以解决请求的 `key` 变化不频繁的情况。如果遭到恶意攻击，每次构建不同的请求 `key`，会导致 `Redis` 中缓存大量无效的 `key`。

* **布隆过滤器。**

  布隆过滤器可以快速判断一个元素是否存在。

  **布隆过滤器判断某个元素存在，小概率会误判。布隆过滤器判断某个元素不在，那么这个元素一定不在。**

  把所有可能存在的请求的值都存放在布隆过滤器中，先判断客户端发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息，存在的话再继续去缓存和数据库中寻找数据。

##### 缓存雪崩

缓存在同一时间大面积的失效，请求直接落到了数据库上，造成数据库短时间内承受大量请求。

解决办法：

* **针对 `Redis` 服务不可用的情况：**
  1. 采用 `Redis` 集群，避免单机出现问题整个缓存服务都没办法使用。
  2. 限流，避免同时处理大量的请求。

* **针对热点缓存失效的情况：**
  1. 设置不同的失效时间 (随机设置缓存失效时间)。
  2. 热点数据缓存永不失效。

##### 如何保证缓存和数据库数据的一致性？

Cache Aside Pattern（旁路缓存模式）

// TODO



### 缓存读写策略？



