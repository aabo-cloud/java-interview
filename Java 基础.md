

[TOC]

## Java 基础

### Java 面向对象

把事物抽象成一个个类，事物拥有的特征称为属性，事物的行为称为方法；再由类派生出一个个具体的对象，每个对象有自己的特征。

#### Java 语言/面向对象 三大特性？

封装、继承和多态

封装是指将对象的属性私有化，提供一些可以访问属性的方法，可以通过访问这些方法得到对象的属性。

继承是指某新类继承已经存在的类，该新类拥有被继承的类的所有属性和方法，并且新类可以根据自己的情况拓展属性或方法。其中新类称为子类，原存在的类被称为父类。通过使用继承，可以快速地创建新的类，从而提高代码的重用性和可维护性，提高开发效率。

多态我的理解是不同的类对同一个行为具有多个不同表现形式。在 `Java` 中有两种形式可以实现多态：继承 (多个子类对同一方法的重写) 和接口 (多个类实现接口并覆盖接口中同一方法)。

#### 重载与重写的区别？

重载发生在同一个类中，具有相同方法名，但是有不同的参数或者参数个数或者不同的参数顺序的方法。比如构造方法。

重写是发生在当子类继承父类时，对父类中的一些方法根据自己的需求进行重写操作。

| 区别点     | 重载方法 | 重写方法                                                     |
| :--------- | :------- | :----------------------------------------------------------- |
| 发生范围   | 同一个类 | 子类                                                         |
| 参数列表   | 必须修改 | 一定不能修改                                                 |
| 返回类型   | 可修改   | 子类方法返回值类型**小于等于**父类方法返回值类型             |
| 异常       | 可修改   | 子类方法声明抛出的异常类**小于等于**父类方法声明抛出的异常类 |
| 访问修饰符 | 可修改   | 访问修饰符范围**大于等于**父类。父类被 private/final/static 修饰不能重写 |
| 发生阶段   | 编译期   | 运行期                                                       |

#### 接口和抽象类有什么共同点和区别？

**共同点** ：

- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法 (Java 8 可以用 `default` 关键在接口中定义默认方法)。

**区别** ：

- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如抽象一个发送短信的抽象类）。?
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 `default`，可在子类中被重新定义，也可被重新赋值。

#### 引用拷贝、浅拷贝和深拷贝?

引用拷贝：两个不同的引用指向同一个对象。

浅拷贝：浅拷贝会在堆上创建一个新的对象 (区别于引用拷贝的一点)，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。

深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

#### 内部类?

内部类有四种，分别是 `成员内部类`、`静态内部类` 、`局部内部类` 和 `匿名内部类`。

成员内部类：定义在类中的类，最基本的内部类。

静态内部类：使用 `static` 来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。

局部内部类：定义在方法中的类。

匿名内部类：

在实际开发中遇到这种情况：**一个接口/类的**方法的**某个实现方式**在程序中**只会执行一次**，但为了使用它，我们需要创建它的实现类/子类去实现/重写。

可以使用匿名内部类的方式，无需创建新的类，直接 `new` 一个对象并重写需要重新实现的方法。

> 匿名内部类可以用在具体类、抽象类和接口上

#### final 关键字？

`final` 关键字可以修饰类、方法和属性。

当 `final` 修饰类的时候，表明**这个类不能被继承**。`final` 类中的所有成员方法都会被隐式地指定为 `final` 方法。

当 `final` 修饰方法的时候，表明这个方法不能被重写。

当 `final` 修饰属性的时候，如果是基本数据类型的变量，则其数值一旦在初始化之后便**不能更改**；如果是引用类型的变量，则在对其初始化之后便**不能再让其指向另一个对象**。

### Java 数据类型

| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   |
| :-------- | :--- | :--- | :------ | ------------------------------------------ |
| `byte`    | 8    | 1    | 0       | -128 ~ 127                                 |
| `short`   | 16   | 2    | 0       | -32768 ~ 32767                             |
| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                   |
| `long`    | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |
| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535                                  |
| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |
| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |
| `boolean` | 1    |      | false   | true、false                                |

#### 基本类型和包装类型的区别？

- 包装类型不赋值就是 `null` ，而基本类型有默认值。

- 包装类型可用于泛型，而基本类型不可以。

- 基本数据类型的局部变量存放在 `Java` 虚拟机栈中的局部变量表中。

  基本数据类型的成员变量 (未被 `static` 修饰) 存放在 `Java` 虚拟机的堆中。

  包装类型属于对象类型，几乎所有对象实例都存在于堆中。

- 相比于包装类型，基本数据类型占用的空间更小。

  包装类占用的内存大小 = 对象头 (`header`) 大小 + 基本数据类型的大小。
  
  对于基本类型 `int` 只占用 `4` 个字节。包装类型 `Integer` 还需要加上对象头 `header` 所占用的 `12` 字节。

#### 包装类的缓存机制？

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

`Byte`, `Short`, `Integer`, `Long` 这 `4` 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据。

`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

超出缓存范围就会创建新的对象。

两种浮点数类型的包装类 `Float`, `Double` 并没有实现缓存机制。

```java
// 下面两行是等价的
Integer num1 = 123;
Integer num2 = Integer.valueOf(123);	// 发生了装箱
// 只要 new 了，就创建了新对象 num1 == num2 != num3
Integer num3 = new Integer(123);
```

#### `==` 与 `equals` 的区别？

`==` ：基本数据类型比较的是值是否相等，引用数据类型判断的是两个对象的地址是否相等

`equals` ：如果类中没有重写 `equals()` 方法，等价于使用 `==` 来比较两个对象；如果重写了 `equals()` 方法，则使用重写的方法来判断两个对象是否相等。

#### hashCode() 的作用？

获取对象在哈希表中的索引位置。

`Object` 的 `hashCode()` 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。

其实，`hashCode()` 和 `equals()` 都是用于比较两个对象是否相等。

#### 为什么两个对象有相同的 `hashCode` 值，它们也不一定是相等的？

因为多个不同的对象通过哈希算法可能计算出相同的 hashCode 值，这时候就还需要 equals() 方法来判断两个对象是否相同。

- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。
- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。
- 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。

所以重写 `equals()` 时必须重写 `hashCode()` 方法.。

#### String、StringBuffer、StringBuilder 的区别？

`String` 类型中使用 `final` 关键字来修饰字符数组，所以 `String` 对象是不可修改的。

> `final` 修饰的字符数组是一个引用类型，这里只是该引用不能再指向其他对象，并不是不能修改字符数组的内容。
>
> `String` 真正不可变有下面几点原因：
>
> 1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
> 2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，没有用 `final` 关键字修饰字符数组，所以这两种类的对象是可以修改的。`StringBuffer` 在方法中加了同步锁，所以是线程安全的。`StringBuilder` 不是线程安全的。

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

#### 字符串拼接用 "+" 还是 StringBuilder ？

Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。

字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

比较明显的缺陷就是编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象。

建议直接使用 `StringBuilder` 进行拼接。

#### 字符串常量池的作用？

`JVM` 为了提升性能和减少内存消耗针对字符串 (String 类) 专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

```java
// 在堆中创建字符串对象"ab"
// 将字符串对象"ab"的引用保存在字符串常量池中
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa == bb);// true
```

####  String s1 = new String("abc"); 这句话创建了几个字符串对象？

// TODO



#### intern 方法有什么作用?

// TODO



#### String 类型的变量和常量做“+”运算时发生了什么？

// TODO



#### 为什么 Java 只有值传递？

程序设计语言将实参传递给方法的方式分为两种：

- **值传递**：方法接收的是实参值的拷贝，会创建副本。
- **引用传递**：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。

Java 中将实参传递给方法的方式是 **值传递** ：

- 如果参数是基本类型，传递的就是基本类型的字面量值的拷贝，会创建副本。
- 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。



### Java 异常

`Java` 中的异常分为 `Error` 和 `Exception`

![Inkedtypes-of-exceptions-in-java](Java 基础.assets/Inkedtypes-of-exceptions-in-java.jpg)

#### Exception 和 Error 有什么区别？

- **`Exception`**：程序可以处理的异常，可以通过 `catch` 捕获或 `Throws` 抛出。`Exception` 分为 `Checked Exception` (受检查异常，必须处理) 和 `Unchecked Exception` (不受检查异常，可以不处理) 两种。

  - 代码在编译过程中，如果受检查异常没有被 `catch` 或者 `throws` 关键字处理的话，无法通过编译。除了 `RuntimeException` 及其子类以外，其他的 `Exception` 类及其子类都属于受检查异常 。

    > 常见的受检查异常：IO 相关的异常、`ClassNotFoundException` 、`SQLException`...。

  - 代码在编译过程中 ，即使不处理不受检查异常也可以正常通过编译。`RuntimeException` 及其子类都属于非受检查异常。

    > 常见的非受检查异常：`NullPointerException`、`ArrayIndexOutOfBoundsException`、`ClassCastException`...

- **`Error`** ：`Error` 属于程序无法处理的错误。例如虚拟机运行错误 (`Virtual MachineError`)、虚拟机内存溢出错误 (`OutOfMemoryError`)、栈溢出错误 (`StackOverFlowError`) 等 。这些异常发生时，Java 虚拟机一般会终止线程。

#### try-catch-finally 如何使用？

- `try` 块： 用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，必须跟一个 `finally` 块。
- `catch` 块： 用于处理 `try` 捕获到的异常。
- `finally` 块：无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。

> **注意：不要在 finally 语句块中使用 return。** 当 `try`  `catch` 语句和 `finally` 语句中都有 `return` 语句时， `try` `catch` 语句块中的 `return` 语句会被忽略。这是因为 `try` 语句中的 `return` 返回值会先被暂存在一个本地变量中，当执行到 `finally` 语句中的 `return` 之后，这个本地变量的值就变为了 `finally` 语句中的 `return` 返回值。

#### finally 中的代码一定会执行吗？

不一定。

`finally` 执行之前虚拟机被终止运行、程序所在的线程死亡，`finally` 中的代码就不会被执行。



### 泛型

#### 什么是 Java 泛型 (Generics) ？有什么作用？

使用泛型参数，可以增强代码的可读性以及稳定性。

编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 `ArrayList<Person> persons = new ArrayList<Person>()` 这行代码就指明了该 `ArrayList` 对象只能传入 `Person` 对象，如果传入其他类型的对象就会报错。

#### 泛型的使用方式有哪几种？

泛型一般有三种使用方式：**泛型类**、**泛型接口**、**泛型方法**。

#### 项目中哪里用到了泛型？

- 自定义接口通用返回结果 `Result<T>` 通过参数 `T` 可根据具体的返回类型动态指定结果的数据类型
- 定义 `Excel` 处理类 `ExcelUtil<T>` 用于动态指定 `Excel` 导出的数据类型
- 构建集合工具类（参考 `Collections` 中的 `sort`, `binarySearch` 方法）。



### Java 反射&代理

反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法并调用他们。

#### 反射的应用场景

`Spring`、`Spring Boot`、`MyBatis` 等等框架中都大量使用了动态代理，而动态代理依赖反射实现。

`Java` 注解也是使用反射实现的

#### 代理模式

使用代理对象来代替对真实对象 (real object) 的访问，这样就可以在不修改原目标对象的前提下，扩展目标对象的功能。比如说在目标对象的某个方法执行前后增加一些自定义的操作。

#### 静态代理

静态代理中，对目标对象方法的增强是手动完成的，接口一旦新增加方法，目标对象和代理对象都要进行修改。需要对每个目标类都写一个代理类。

静态代理步骤：

1. 定义一个接口及其实现类。
2. 创建一个代理类同样实现这个接口。
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些增强。

#### 动态代理

动态代理不需要针对每个目标类都创建一个代理类，使用 `JDK 动态代理` 需要目标类实现了接口， 如果使用 `CGLIB 动态代理` 不需要实现接口。

从 `JVM` 角度来说，动态代理是在运行时动态生成类字节码，并加载到 `JVM` 中的。

`Spring AOP`、`RPC` 框架的实现都依赖了动态代理。

##### JDK 动态代理



步骤：

1. 定义一个接口及其实现类；

2. 自定义 `InvocationHandler` 并重写其中的 `invoke` 方法，在 `invoke` 方法中调用被代理类的方法并自定义一些处理逻辑；

3. 通过 `Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)` 创建代理对象；

   传入目标类的类加载器、代理类需要实现的接口、自定义的 `InvocationHandler`。

4. 当返回的对象调用对应的方法时，会调用 `InvocationHandler` 中的 `invoke` 方法，实现了对方法的增强。



newProxyInstance 原理：

// TODO



##### CGLIB 动态代理

`JDK` 动态代理的问题是只能代理实现了接口的类。为了解决这个问题，可以用 `CGLIB` 动态代理。

步骤：

// TODO



#### JDK 动态代理和 CGLIB 动态代理对比？

1. **JDK 动态代理只能代理实现了接口的类或者直接代理接口，CGLIB 可以代理未实现接口的类。** 

   `CGLIB` 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 `final` 类型的类和方法。

2. `JDK 1.8` 之后 `JDK` 动态代理的效率更高。

#### 静态代理和动态代理的对比？

1. **编码层面**：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。使用静态代理，接口一旦新增加方法，目标对象和代理对象都要进行修改。
2. **JVM 层面**：静态代理在编译时就将接口、实现类、代理类这些都变成了 `.class` 文件。而动态代理是在运行时动态生成类字节码，并加载到 `JVM` 中的。

### 

### Java I/O

I/O（**I**nput/**O**utpu） 即**输入／输出** 。

* 计算机体系结构的角度：根据冯诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。那么这里的输入、输出可以理解为，输入设备向计算机输入数据 (键盘、鼠标)，输出设备接收计算机输出的数据 (显示器、打印机)。
* 应用程序的角度：当应用程序需要对文件进行读取时，应用程序会对操作系统内核发起 `I/O调用 (系统调用)`，操作系统内核会执行具体的 I/O 操作。此时内核会等待 I/O 设备准备好数据，准备好之后把数据从 `内核空间` 拷贝到 `用户空间` 。

#### Java I/O 模型

##### BIO (Blocking I/O)

BIO 属于同步阻塞 IO 模型 。应用程序发起 `read` 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。

##### NIO (Non-blocking/New I/O)

NIO 在 BIO 的基础上进行了改进，应用程序发起 `read` 调用后，如果没有读取到并不会阻塞而是直接返回，通过轮询的方式，间隔一段时间再去读取，避免了阻塞的发生。但每次检测调用 `read` 都会发生上下文切换，代价较大。轮询也非常消耗 CPU 资源。如果有多个 IO 需要处理，消耗会更大。

##### IO 多路复用

线程首先发起 `select` 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 `read` 调用。`read` 调用的过程 (数据从内核空间 -> 用户空间) 还是阻塞的。

但是 `select调用` 一次性可以查询多个系统调用的状态，那么使用单线程就可以控制多个客户端的 IO 连接，通过选择器监听多个通道，如果非阻塞就返回数据。

#####  AIO (Asynchronous I/O)

异步 IO 是基于事件和回调机制实现的，也就是应用发起 `read调用` 之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

####  什么是序列化? 什么是反序列化?

- **序列化**：将数据结构或对象转换成二进制字节流的过程
- **反序列化**：将序列化所生成的二进制字节流转换成数据结构或者对象的过程

#### 实际开发中有哪些用到序列化和反序列化的场景？

1. 对象在进行网络传输 (比如远程过程调用 RPC 的时候) 之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
2. 将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化。
3. 将对象存储到缓存数据库 (如 Redis) 时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化。

#### 常见序列化协议

> `OSI` 七层协议模型中，`表示层` 做的事情主要就是对 `应用层` 的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成 `应用层` 的用户数据。所以序列化协议对应着 `表示层`。

`JDK` 自带的序列化方式实现 `java.io.Serializable` 接口即可。其中序列化号 `serialVersionUID` 属于版本控制的作用。序列化的时候 `serialVersionUID` 也会被写入二进制序列，当反序列化时会检查 `serialVersionUID` 是否和当前类的 `serialVersionUID` 一致。如果 `serialVersionUID` 不一致则会抛出 `InvalidClassException` 异常。一般不使用 `JDK` 自带的序列化方式，因为序列化效率低并且部分版本有安全漏洞。

其他比较常用的序列化协议有 `hessian`、`kyro`、`protostuff`。这些都是基于二进制的序列化协议，像 `JSON` 和 `XML` 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差。

**`kyro`**：

// TODO







#### Java 序列化中如果有些字段不想进行序列化，怎么办？

对于不想进行序列化的变量，使用 `transient` 关键字修饰。

`transient` 关键字阻止实例中那些用此关键字修饰的的变量序列化。

关于 `transient` 还有几点注意：

- `transient` 只能修饰变量，不能修饰类和方法。
- `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
- `static` 变量因为不属于任何对象 (`Object`) ，所以无论有没有 `transient` 关键字修饰，均不会被序列化。

#### Java 中 IO 流分为几种?

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。

#### 有字节流，为什么还要有字符流?

虽然存储的最小单元是 `字节`，但是如果没有 `字符流`，就需要把 `字节流` 转换成 `字符流`，这个过程比较耗时；如果不知道编码类型还容易出现乱码问题。所以直接 `IO` 直接提供了一个操作 `字符流` 的接口，方便对 `字符` 进行操作。
