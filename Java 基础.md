## Java 基础



### Java 面向对象

#### Java 语言三大特性？

封装、继承和多态

封装是指将对象的属性私有化，提供一些可以访问属性的方法，我们通过访问这些方法得到对象的属性。

继承是指某新类继承已经存在的类，该新类拥有被继承的类的所有属性和方法，并且新类可以根据自己的情况拓展属性或方法。其中新类称为子类，原存在的类被称为父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高开发效率。

多态我的理解是不同的类对同一个行为具有多个不同表现形式。在 Java 中有两种形式可以实现多态：继承 (多个子类对同一方法的重写) 和接口 (多个类实现接口并覆盖接口中同一方法)。

#### 重载与重写的区别？

重载发生在同一个类中，具有相同方法名，但是有不同的参数或者参数个数或者不同的参数顺序的方法。比如构造方法。

重写是发生在当子类继承父类时，对父类中的一些方法根据自己的需求进行重写操作。

| 区别点     | 重载方法 | 重写方法                                                     |
| :--------- | :------- | :----------------------------------------------------------- |
| 发生范围   | 同一个类 | 子类                                                         |
| 参数列表   | 必须修改 | 一定不能修改                                                 |
| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等 |
| 访问修饰符 | 可修改   | 访问修饰符范围大于等于父类。父类被 private/final/static 修饰不能重写 |
| 发生阶段   | 编译期   | 运行期                                                       |

#### 接口和抽象类有什么共同点和区别？

**共同点** ：

- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法 (Java 8 可以用 `default` 关键在接口中定义默认方法)。

**区别** ：

- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如抽象一个发送短信的抽象类）。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 `default`，可在子类中被重新定义，也可被重新赋值。

#### 引用拷贝、浅拷贝和深拷贝?

引用拷贝：两个不同的引用指向同一个对象。

浅拷贝：浅拷贝会在堆上创建一个新的对象 (区别于引用拷贝的一点)，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。

深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

#### 内部类?

内部类有四种，分别是 `静态内部类` 、`局部内部类` 、`匿名内部` 和 `成员内部类`。

成员内部类：定义在一个类中的类，最基本的内部类

静态内部类：使用 `static` 来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。称为静态内部类

局部内部类：定义在方法中的类叫做局部内部类

匿名内部类：是指使用继承一个父类或者实现一个接口这两种方式直接定义并使用的类，匿名内部类没有class关键字，直接使用 `new` 生成一个对象

#### final 关键字?

`final` 关键字可以修饰类、方法和属性。

当final修饰类的时候，表明**这个类不能被继承**。final 类中的所有成员方法都会被隐式地指定为 final 方法。

当final修饰方法的时候，表明这个方法不能被重写。

当final修饰属性的时候，如果是基本数据类型的变量，则其数值一旦在初始化之后便**不能更改**；如果是引用类型的变量，则在对其初始化之后便**不能再让其指向另一个对象**。

### Java 数据类型

| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   |
| :-------- | :--- | :--- | :------ | ------------------------------------------ |
| `byte`    | 8    | 1    | 0       | -128 ~ 127                                 |
| `short`   | 16   | 2    | 0       | -32768 ~ 32767                             |
| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                   |
| `long`    | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |
| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535                                  |
| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |
| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |
| `boolean` | 1    |      | false   | true、false                                |

#### 基本类型和包装类型的区别？

- 包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。

- 包装类型可用于泛型，而基本类型不可以。

- 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量 (未被 `static` 修饰) 存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。

- 相比于对象类型，基本数据类型占用的空间更小。

  包装类占用的内存大小 = 对象头 (header) 大小 + 基本数据类型的大小。对于基本类型 `int` 只占用 4 个字节。但是包装类型 `Integer` 还需要加上对象头 header 所占用的 12 字节。

#### 包装类的缓存机制？

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

`Byte`, `Short`, `Integer`, `Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。超出范围会创建新的对象。

两种浮点数类型的包装类 `Float`, `Double` 并没有实现缓存机制。

```java
// 下面两行是等价的
Integer num1 = 123;
Integer num2 = Integer.valueOf(123);	// 发生了装箱
// 只要 new 了，就创建了新对象 num1 == num2 != num3
Integer num3 = new Integer(123);
```

#### `==` 与 `equals` 的区别？

`==` ：基本数据类型比较的是值是否相等，引用数据类型判断的是两个对象的地址是否相等

`equals` ：如果类中没有重写 `equals()` 方法，等价于使用 `==` 来比较两个对象；如果重写了 `equals()` 方法，则使用重写的方法来判断两个对象是否相等。

#### hashCode() 的作用？

获取对象在哈希表中的索引位置。

`Object` 的 `hashCode()` 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。

其实，`hashCode()` 和 `equals()` 都是用于比较两个对象是否相等。

#### 为什么两个对象有相同的 `hashCode` 值，它们也不一定是相等的？

因为多个不同的对象通过哈希算法可能计算出相同的 hashCode 值，这时候就还需要 equals() 方法来判断两个对象是否相同。

- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。
- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。
- 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。

所以重写 `equals()` 时必须重写 `hashCode()` 方法.。

#### String、StringBuffer、StringBuilder 的区别？

`String` 类型中使用 `final` 关键字来修饰字符数组，所以 `String` 对象是不可修改的。

> `final` 修饰的字符数组是一个引用类型，这里只是该引用不能再指向其他对象，并不是不能修改字符数组的内容。
>
> `String` 真正不可变有下面几点原因：
>
> 1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
> 2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，没有用 `final` 关键字修饰字符数组，所以这两种类的对象是可以修改的。`StringBuffer` 在方法中加了同步锁，所以是线程安全的。`StringBuilder` 不是线程安全的。

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

#### 字符串拼接用 "+" 还是 StringBuilder ？

Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。

字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

比较明显的缺陷就是编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象。

建议直接使用 `StringBuilder` 进行拼接。

#### 字符串常量池的作用？

`JVM` 为了提升性能和减少内存消耗针对字符串 (String 类) 专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

```java
// 在堆中创建字符串对象"ab"
// 将字符串对象"ab"的引用保存在字符串常量池中
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa == bb);// true
```

####  String s1 = new String("abc"); 这句话创建了几个字符串对象？

// TODO



#### intern 方法有什么作用?

// TODO



#### String 类型的变量和常量做“+”运算时发生了什么？

// TODO



#### 为什么 Java 只有值传递？

程序设计语言将实参传递给方法的方式分为两种：

- **值传递**：方法接收的是实参值的拷贝，会创建副本。
- **引用传递**：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。

Java 中将实参传递给方法的方式是 **值传递** ：

- 如果参数是基本类型，传递的就是基本类型的字面量值的拷贝，会创建副本。
- 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。



### Java 异常

`Java` 中的异常分为 `Error` 和 `Exception`

![Inkedtypes-of-exceptions-in-java](Java 基础.assets/Inkedtypes-of-exceptions-in-java.jpg)

#### Exception 和 Error 有什么区别？

- **`Exception`**：程序可以处理的异常，可以通过 `catch` 捕获或 `Throws` 抛出。`Exception` 分为 `Checked Exception` (受检查异常，必须处理) 和 `Unchecked Exception` (不受检查异常，可以不处理) 两种。

  - 代码在编译过程中，如果受检查异常没有被 `catch` 或者 `throws` 关键字处理的话，无法通过编译。除了 `RuntimeException` 及其子类以外，其他的 `Exception` 类及其子类都属于受检查异常 。

    > 常见的受检查异常：IO 相关的异常、`ClassNotFoundException` 、`SQLException`...。

  - 代码在编译过程中 ，即使不处理不受检查异常也可以正常通过编译。`RuntimeException` 及其子类都属于非受检查异常。

    > 常见的非受检查异常：`NullPointerException`、`ArrayIndexOutOfBoundsException`、`ClassCastException`...

- **`Error`** ：`Error` 属于程序无法处理的错误。例如虚拟机运行错误 (`Virtual MachineError`)、虚拟机内存溢出错误 (`OutOfMemoryError`)、栈溢出错误 (`StackOverFlowError`) 等 。这些异常发生时，Java 虚拟机一般会终止线程。

#### try-catch-finally 如何使用？

- `try` 块： 用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，必须跟一个 `finally` 块。
- `catch` 块： 用于处理 `try` 捕获到的异常。
- `finally` 块：无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。

> **注意：不要在 finally 语句块中使用 return。** 当 `try`  `catch` 语句和 `finally` 语句中都有 `return` 语句时， `try` `catch` 语句块中的 `return` 语句会被忽略。这是因为 `try` 语句中的 `return` 返回值会先被暂存在一个本地变量中，当执行到 `finally` 语句中的 `return` 之后，这个本地变量的值就变为了 `finally` 语句中的 `return` 返回值。

#### finally 中的代码一定会执行吗？

不一定。

`finally` 执行之前虚拟机被终止运行、程序所在的线程死亡，`finally` 中的代码就不会被执行。



### 泛型

#### 什么是 Java 泛型 (Generics) ？有什么作用？

使用泛型参数，可以增强代码的可读性以及稳定性。

编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 `ArrayList<Person> persons = new ArrayList<Person>()` 这行代码就指明了该 `ArrayList` 对象只能传入 `Person` 对象，如果传入其他类型的对象就会报错。

#### 泛型的使用方式有哪几种？

泛型一般有三种使用方式：**泛型类**、**泛型接口**、**泛型方法**。

#### 项目中哪里用到了泛型？

- 自定义接口通用返回结果 `Result<T>` 通过参数 `T` 可根据具体的返回类型动态指定结果的数据类型
- 定义 `Excel` 处理类 `ExcelUtil<T>` 用于动态指定 `Excel` 导出的数据类型
- 构建集合工具类（参考 `Collections` 中的 `sort`, `binarySearch` 方法）。



### Java 反射&代理

反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。



#### 反射的应用场景

`Spring`、`Spring Boot`、`MyBatis` 等等框架中都大量使用了动态代理，而动态代理依赖反射实现。

`Java` 注解也是使用反射实现的

#### 代理模式

使用代理对象来代替对真实对象 (real object) 的访问，这样就可以在不修改原目标对象的前提下，扩展目标对象的功能。比如说在目标对象的某个方法执行前后增加一些自定义的操作。

#### 静态代理

静态代理中，对目标对象方法的增强是手动完成的，接口一旦新增加方法，目标对象和代理对象都要进行修改。需要对每个目标类都写一个代理类。

静态代理步骤：

1. 定义一个接口及其实现类。
2. 创建一个代理类同样实现这个接口。
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些增强。

#### 动态代理

动态代理不需要针对每个目标类都创建一个代理类，使用 `JDK 动态代理` 需要目标类实现了接口， 如果使用 `CGLIB 动态代理` 不需要实现接口。

从 `JVM` 角度来说，动态代理是在运行时动态生成类字节码，并加载到 `JVM` 中的。

`Spring AOP`、`RPC` 框架的实现都依赖了动态代理。

##### JDK 动态代理机制



步骤：

1. 定义一个接口及其实现类；

2. 自定义 `InvocationHandler` 并重写其中的 `invoke` 方法，在 `invoke` 方法中调用被代理类的方法并自定义一些处理逻辑；

3. 通过 `Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)` 创建代理对象；

   传入目标类的类加载器、代理类需要实现的接口、自定义的 `InvocationHandler`。

4. 当返回的对象调用对应的方法时，会调用 `InvocationHandler` 中的 `invoke` 方法，实现了对方法的增强。



newProxyInstance 原理：

// TODO



### Java I/O

####  什么是序列化? 什么是反序列化?

- **序列化**：将数据结构或对象转换成二进制字节流的过程
- **反序列化**：将序列化所生成的二进制字节流转换成数据结构或者对象的过程

#### 实际开发中有哪些用到序列化和反序列化的场景？

1. 对象在进行网络传输 (比如远程过程调用 RPC 的时候) 之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
2. 将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化。
3. 将对象存储到缓存数据库 (如 Redis) 时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化。

#### 常见序列化协议

> `OSI` 七层协议模型中，`表示层` 做的事情主要就是对 `应用层` 的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成 `应用层` 的用户数据。所以序列化协议对应着 `表示层`。

`JDK` 自带的序列化方式实现 `java.io.Serializable` 接口即可。其中序列化号 `serialVersionUID` 属于版本控制的作用。序列化的时候 `serialVersionUID` 也会被写入二进制序列，当反序列化时会检查 `serialVersionUID` 是否和当前类的 `serialVersionUID` 一致。如果 `serialVersionUID` 不一致则会抛出 `InvalidClassException` 异常。一般不使用 `JDK` 自带的序列化方式，因为序列化效率低并且部分版本有安全漏洞。

其他比较常用的序列化协议有 `hessian`、`kyro`、`protostuff`。这些都是基于二进制的序列化协议，像 `JSON` 和 `XML` 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差。

**`kyro`**：

// TODO





#### Java 序列化中如果有些字段不想进行序列化，怎么办？

对于不想进行序列化的变量，使用 `transient` 关键字修饰。

`transient` 关键字阻止实例中那些用此关键字修饰的的变量序列化。

关于 `transient` 还有几点注意：

- `transient` 只能修饰变量，不能修饰类和方法。
- `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
- `static` 变量因为不属于任何对象 (`Object`) ，所以无论有没有 `transient` 关键字修饰，均不会被序列化。

#### Java 中 IO 流分为几种?

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。

#### 有字节流，为什么还要有字符流?

虽然存储的最小单元是 `字节`，但是如果没有 `字符流`，就需要把 `字节流` 转换成 `字符流`，这个过程比较耗时；如果不知道编码类型还容易出现乱码问题。所以直接 `IO` 直接提供了一个操作 `字符流` 的接口，方便对 `字符` 进行操作。

